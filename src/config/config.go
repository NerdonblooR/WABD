package config

import (
	"dlog"
	"encoding/json"
	"flag"
	"os"
)

var configFile = flag.String("config", "config.json", "Configuration file for paxi replica. Defaults to config.json.")

type ID string

const (
	HYBRID int = iota
	CABD
	PUREWATER
	CLASSIC
)

// Bconfig holds all benchmark configuration
type Bconfig struct {
	T                    int     // total number of running time in seconds
	N                    int     // total number of requests
	K                    int     // key sapce
	W                    float64 // write ratio
	Throttle             int     // requests per second throttle, unused if 0
	Concurrency          int     // number of simulated clients
	Distribution         string  // distribution
	LinearizabilityCheck bool    // run linearizability checker at the end of benchmark
	// rounds       int    // repeat in many rounds sequentially

	// conflict distribution
	Conflicts int // percentage of conflicting keys
	Min       int // min key

	// normal distribution
	Mu    float64 // mu of normal distribution
	Sigma float64 // sigma of normal distribution
	Move  bool    // moving average (mu) of normal distribution
	Speed int     // moving speed in milliseconds intervals per key

	// zipfian distribution
	ZipfianS     float64 // zipfian s parameter
	ZipfianV     float64 // zipfian v parameter
	ZipfianTheta float64 // zipfian alpha = 1 / (1 - theta)

	// exponential distribution
	Lambda      float64 // rate parameter
	DumpLatency bool
}

// Config contains every system configuration
type Config struct {
	Addrs     map[ID]string `json:"address"`      // address for node communication
	SubAddrs  map[ID]string `json:"sub_address"`  // address for sub nodes communication
	HTTPAddrs map[ID]string `json:"http_address"` // address for client server communication

	JustReply      bool `json:"just_reply"`
	DoProfile      bool `json:"do_profile"`
	DoMonitor      bool `json:"do_monitor"`
	Thrifty        bool `json:"thrifty"`          // only send messages to a quorum
	BufferSize     int  `json:"buffer_size"`      // buffer size for maps
	ChanBufferSize int  `json:"chan_buffer_size"` // buffer size for channels
	BatchSize      int  `json:"batch_size"`
	MultiVersion   bool `json:"multiversion"`           // create multi-version database
	ShardNum       int  `json:"shard_number"`           //number of shard of in-memory map
	WatermarkOpt   bool `json:"watermark_optimization"` //perform watermark optmization
	AbdType        int  `json:"abd_type"`               //type of ABD
	ReadThresh     int  `json:"read_thresh"`            //C to decide whether to do delta read
	Delay          int  `json:"delay"`                  //time delay for issuing delta read
	Offset         int  `json:"offset"`                 //clock offset
	WorkerNum      int  `json:"worker_num"`             //how many transaction handlers

	Benchmark Bconfig `json:"benchmark"` // benchmark configuration

	// for future implementation
	// Batching bool `json:"batching"`
	// Consistency string `json:"consistency"`
	// Codec string `json:"codec"` // codec for message serialization between nodes
	n int // total number of nodes
}

// Config is global configuration singleton generated by init() func below
var config Config

func init() {
	config = MakeDefaultConfig()
}

// GetConfig returns configuration
func GetConfig() Config {
	return config
}

// Simulation enable go channel transportation to simulate distributed environment
// func Simulation() {
// 	*scheme = "chan"
// }

// MakeDefaultConfig returns Config object with few default values
// only used by init() and master
func MakeDefaultConfig() Config {
	return Config{
		BufferSize:     1024,
		ChanBufferSize: 1024,
		MultiVersion:   false,
		// Benchmark:      DefaultBConfig(),
	}
}

// IDs returns all node ids
func (c Config) IDs() []ID {
	ids := make([]ID, 0)
	for id := range c.Addrs {
		ids = append(ids, id)
	}
	return ids
}

// N returns total number of nodes
func (c Config) N() int {
	return c.n
}

// String is implemented to print the config
func (c Config) String() string {
	config, err := json.Marshal(c)
	if err != nil {
		dlog.Error(err)
		return ""
	}
	return string(config)
}

func Load() {
	config.Load()
}

// Load loads configuration from config file in JSON format
func (c *Config) Load() {
	file, err := os.Open(*configFile)
	if err != nil {
		dlog.Fatal(err)
	}
	decoder := json.NewDecoder(file)
	err = decoder.Decode(c)
	if err != nil {
		dlog.Fatal(err)
	}
	c.n = len(c.Addrs)
}

// Save saves configuration to file in JSON format
func (c Config) Save() error {
	file, err := os.Create(*configFile)
	if err != nil {
		return err
	}
	encoder := json.NewEncoder(file)
	return encoder.Encode(c)
}
